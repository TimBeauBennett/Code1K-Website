{% block content %}

<h3>Chapter 7 - String Fundamentals</h3>

  <h4>1: Can the string find method be used to search a list?</h4>
    <p> - My Answer: No. A list is a sequence like a string, but I believe the find
      method is one specific to strings, not generic among sequences. That could be
      wrong though. </p>
    <p> - Mark's Answer: No, because methods are always type-specificl that is they
      only work on a single data type. Expressions like X + Y and built in functions
      like len(x) are genercic, though and may work on a variety of types. In this
      case, for instance, the in membership expression has a similar effect as the
      string find, but it can be used to search both strings and lists. In Python
      3.0, there is some attempt to group methods by categories (for example, the
      mutable sequence types list and bytarray have similar method sets), but
      methods are still more type-specific that other operation sets.</p>

  <h4>2: Can a string slice expression be used on a list?</h4>
    <p> - My Answer: Yes, because the slice expression acts on strings as sequences.
      Therefore, the expression is generic to all sequences, including lists.</p>
    <p> - Mark's Answer: Yes. Unlike methods, expressions are generic and apply to
      many types. In this case, the slice expression is really a sequence
      operation - it works on any type of equence obect, inluding strings, lists,
      and tuples. The only difference is that when you slice a list, you get back a
      new list.</p>

  <h4>3: How would you convert a character to its ASCII integer code? How would you
    convert the other way, from an integer to a character?</h4>
    <p> - My Answer: Converting to ASCII code is done through the asc() function I
      believe (though I'm not 100% sure). What I am sure about is that to convert
      ASCII integer code to its character, you use the chr() function.</p>
    <p> - Mark's Answer: The built in ord(S) function converts from a one-character
      string to an integer character code; chr(I) converts from the integer code back
      to a string. </p>

  <h4>4: How might you go about changing a string in Python?</h4>
    <p> - My Answer: You wouldn't! BAH! Strings are immutable, so can't be changed in
      place. However, you can make a straight copy of a string with an empty slice
      expression ([:]) or you can create a new string in some other way, then assign
      it to the original variable, effectively having changed the original string.
      Alternatively you could assign the new string to a new variable and now you have two!</p>
    <p> - Mark's Answer: Strings cannot be changed; they are immutable. However, you
      can achieve a similar effect by creating a new string - by concatenating, slicing,
      running formatting expressions, or using a method call like replace - and then assiging
      the result back to the original name.</p>

  <h4>5: Given a string S with the value "s,pa,m", name two ways to extract the two
    characters in the middle.</h4>
    <p> - My Answer: Easiest option would be replace. <br/>>>> 's,pa,m'.replace(',', '')<br/>
      Another option would be to rebuild the string through indexing.<br/>
      >>> S = 's,pa,m'<br/>
      >>> S = S[0] + S[2:4] + S[-1]<br/>
      >>> S<br/>
      >>> 'spam'</p>
    <p> - Mark's Answer: You can slice the string using S[2:4], or split on the comma
      and index the string using S.split(',')[1].</p>
    <p> Note: Okay so I misunderstood. But whatever, my solution is more useful.</p>

  <h4>6: How many characters are there in the string "a\nb\x1f\000d"?</h4>
    <p> - My Answer: 7 I think. the escapes only count as one character, and I think
      that '\000d' is one single escape, but I'm not sure. We can check with
      len("a\nb\x1f\000d") though, which I will do now...HA! It was 6. '\000d' is
      just one character, but I missed \xf, which is a hex character, I counted it as 2. </p>
    <p> - Mark's Answer: Six. The string containts the bytes a, newline, b, binary 31,
      binary 0, and d. Pass the string to the built in len function to verify this, and pring each
      of its character's ord results to see the actual byte values.</p>
    <p> Note: So I still got it wrong. I need to work on my binary I think.</p>

  <h4>7: Why might you use the string module instead of string method calls?</h4>
    <p> - My Answer: Maybe if you were using Python 2.1? Otherwise I wouldn't.
      Apparently the module has some other methods that are worth it still existing,
      but I haven't used any of them yet </p>
    <p> - Mark's Answer: You should never use the string module instead of string
      object method calls today - it's deprecated, and its calls are removed completely
      from Python 3.0. The only reason for using the string module at all is for its
      other tools, such as predefined constants. You might aso see it appear in what
      is now very old and dusty Python code.</p>

{% endblock %}
