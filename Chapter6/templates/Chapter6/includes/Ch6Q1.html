{% block content %}
<h2>Chapter 6 - The Dynamic Typing Interlude<h2>

  <h4>1: Consider the following three statements: <br/>
    A = "spam"<br/>
    B = A<br/>
    B = "shrubbery"<br/>
    Do they change the value printed for A?</h4>
    <p> - My Answer: No. A is set to point to the 'spam' string, then B is also made
      to point to the 'spam' object. The B is changed to point to a new object, A is
      not affected, it still points to 'spam'</p>
    <p> - Mark's Answer: No: A still prints as 'spam. When B is assigned to the string
      'shrubbery', all that happens is that the cariable B is reset to point to the new
      string object. A and B initially share (ie reference point to) the same single
      string obect 'spam', but two names are neer liked together in Python. Thus,
      setting B to a different object has no effect on A. The same would be true if
      the last statement here was B = B + 'shrubbery', by the way = the concatenation
      would make a new obecy for its result, which would then be assigned to B only.
      We can nver oerwrie a string(or number, or tuple) in place, because strings are
      immutable. </p>

  <h4>2: Consider these three statements: <br/>
      A = ["spam"]<br/>
      B = A<br/>
      B = "shrubbery"<br/>
      Do they change the value printed for A?</h4>
      <p> - My Answer: Yes. In this case A points to a one item list with 'spam' as
        it's only item. B is then also set to point to the same object. Using B, the
        first/only item is changed to 'shubbery'. As a list is a mutable object it is
        changed in place. A still points to the original object, but that object has
        been altered in place now</p>
      <p> - Mark's Answer: Yes: A now rings as ['shrubbery']. Technically we haven't
        really changed either A or B, intead weve changed part of the object they both
        reference(point to) by overwriting that object in place through the variable B.
        Beause A refrences the same object as B, the update is reflected in A as well.</p>

  <h4>3: How about these:<br/>
        A = ["spam"]<br/>
        B = A<br/>
        B[0] = "shrubbery"<br/>
        is A changed now?</h4>
      <p> - My Answer: Nope. A is set to the list object, the B is set to point to a
        brand new list object, as it's set through a copy function (using the slice
        notation). When the list that B points to is altered in place, it doesn't
        affect A, as B is no pointing to a totally new object.</p>
      <p> - Mark's Answer: No: A still prints as ['spam']. The in-place assignment
        through B has no effect this time because the slice expression made a copy of
        the list object before it ws assigned to B. After the second assignment statement,
        there are two different list objects that have the same value (in Python, we say
        they are ==, but not is). The third statement changes the value of the list
        object pointed to by B, but not that pointed to by A.</p>

{% endblock %}
